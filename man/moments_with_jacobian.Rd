% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/07_jacobian.R
\name{moments_with_jacobian}
\alias{moments_with_jacobian}
\title{Compute Marginal Moments and Jacobian Simultaneously}
\usage{
moments_with_jacobian(J, a, b, M = .QUAD_NODES_DEFAULT)
}
\arguments{
\item{J}{Integer; sample size (number of observations/sites).}

\item{a}{Numeric; shape parameter of the Gamma prior on \eqn{\alpha} (> 0).}

\item{b}{Numeric; rate parameter of the Gamma prior on \eqn{\alpha} (> 0).}

\item{M}{Integer; number of quadrature nodes (default: 80).}
}
\value{
A named list with components:
\describe{
\item{\code{mean}}{Marginal mean \eqn{E[K_J]}}
\item{\code{var}}{Marginal variance \eqn{Var(K_J)}}
\item{\code{jacobian}}{2x2 Jacobian matrix with structure:
\deqn{J_F = \begin{bmatrix} \partial M_1/\partial a & \partial M_1/\partial b \\
                                 \partial V/\partial a & \partial V/\partial b \end{bmatrix}}}
}
}
\description{
Computes the exact marginal moments \eqn{M_1 = E[K_J]} and \eqn{V = Var(K_J)}
along with the Jacobian matrix of the moment map \eqn{F(a,b) = (M_1, V)}
using score function identities.
}
\details{
This function uses the score identity (Lee, 2026, Section 3.2, Corollary 1) to compute exact
derivatives without finite differences:
\deqn{\frac{\partial}{\partial\theta} E[f(\alpha)] = E[f(\alpha) \cdot s_\theta(\alpha)]}

The Jacobian components are computed as:
\itemize{
\item \eqn{\partial M_1/\partial \theta = E[\mu_J(\alpha) \cdot s_\theta(\alpha)]}
\item \eqn{\partial V/\partial \theta = \partial E[v_J]/\partial \theta +
             \partial E[\mu_J^2]/\partial \theta - 2 M_1 \partial M_1/\partial \theta}
}

\strong{Numerical Considerations:}
\itemize{
\item The score function \code{s_a} contains \code{log(alpha)}, which causes
slower quadrature convergence compared to moment computation.
\item For verification, use higher M (e.g., 120-200).
\item Very small alpha values (< 1e-12) are handled with limiting values.
}
}
\examples{
# Compute moments and Jacobian for J=50, a=2, b=1
result <- moments_with_jacobian(J = 50, a = 2.0, b = 1.0)
print(result$mean)      # E[K_J]
print(result$var)       # Var(K_J)
print(result$jacobian)  # 2x2 Jacobian matrix

# Use in Newton iteration
target <- c(5.0, 8.0)  # Target (E[K], Var(K))
current <- c(result$mean, result$var)
residual <- current - target
delta <- solve(result$jacobian, -residual)

}
\references{
Lee, J. (2026). Design-Conditional Prior Elicitation for Dirichlet Process Mixtures.
\emph{arXiv preprint} arXiv:2602.06301.
}
\seealso{
\code{\link{exact_K_moments}} for moments only,
\code{\link{score_a}}, \code{\link{score_b}} for score functions
}
