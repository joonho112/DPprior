% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/15_dual_anchor.R
\name{DPprior_dual}
\alias{DPprior_dual}
\title{Dual-Anchor Prior Calibration}
\usage{
DPprior_dual(
  fit,
  w1_target,
  lambda = 0.5,
  max_iter = 100L,
  verbose = FALSE,
  M = .QUAD_NODES_DEFAULT,
  loss_type = c("relative", "adaptive", "absolute")
)
}
\arguments{
\item{fit}{A \code{DPprior_fit} object from any K-based calibration method.}

\item{w1_target}{List specifying the first-weight target. Options:
\describe{
\item{\code{list(prob = list(threshold = 0.5, value = 0.3))}}{
Constrain \eqn{P(w_1 > 0.5) = 0.3}}
\item{\code{list(quantile = list(prob = 0.9, value = 0.4))}}{
Constrain 90th percentile of \eqn{w_1} = 0.4}
\item{\code{list(mean = 0.3)}}{Constrain \eqn{E[w_1] = 0.3}}
}}

\item{lambda}{Numeric value between 0 and 1; weight on K_J anchor.
Default is 0.5 (balanced). lambda = 1 recovers K-only fit.}

\item{max_iter}{Integer; maximum optimization iterations.}

\item{verbose}{Logical; if TRUE, print progress.}

\item{M}{Integer; quadrature nodes.}

\item{loss_type}{Character; "relative" (default), "adaptive", or "absolute".
See \code{\link{dual_anchor_loss}} for details.}
}
\value{
An S3 object of class \code{"DPprior_fit"}.
}
\description{
Refines a K_J-calibrated prior to also satisfy weight constraints,
implementing the dual-anchor framework from Lee (2026, Section 4).
}
\details{
\subsection{Critical Fix (2025-12-29)}{

The original implementation used absolute squared errors for L_K, causing
severe scale mismatch. The optimizer would essentially ignore the weight
constraint. Example improvement at lambda = 0.5:
\itemize{
\item ABSOLUTE (broken): 0.5 percent reduction in \eqn{P(w_1 > 0.5)}
\item RELATIVE (fixed): 9 percent reduction
\item ADAPTIVE: 18 percent reduction
}
}
}
\section{Choosing loss_type}{

\itemize{
\item \strong{"relative"}: Good default. Both losses dimensionless.
\item \strong{"adaptive"}: More aggressive. Use when you want lambda = 0.5
to give significant weight reduction.
\item \strong{"absolute"}: Legacy, not recommended.
}
}

\examples{
# K-only fit
fit_K <- DPprior_a2_newton(J = 50, mu_K = 5, var_K = 8)
cat("K-only P(w_1 > 0.5):", prob_w1_exceeds(0.5, fit_K$a, fit_K$b), "\n")

# Dual-anchor with relative loss (default)
fit_rel <- DPprior_dual(
  fit_K,
  w1_target = list(prob = list(threshold = 0.5, value = 0.3)),
  lambda = 0.5,
  loss_type = "relative"
)
cat("Relative P(w_1 > 0.5):", fit_rel$dual_anchor$w1_achieved$prob_gt_50, "\n")

# Dual-anchor with adaptive loss (more aggressive)
fit_adp <- DPprior_dual(
  fit_K,
  w1_target = list(prob = list(threshold = 0.5, value = 0.3)),
  lambda = 0.5,
  loss_type = "adaptive"
)
cat("Adaptive P(w_1 > 0.5):", fit_adp$dual_anchor$w1_achieved$prob_gt_50, "\n")

}
\references{
Lee, J. (2026). Design-Conditional Prior Elicitation for Dirichlet Process Mixtures.
\emph{arXiv preprint} arXiv:2602.06301.
}
\seealso{
Other elicitation: 
\code{\link{DPprior_a1}()},
\code{\link{DPprior_a2_kl}()},
\code{\link{DPprior_a2_newton}()},
\code{\link{DPprior_fit}()}
}
\concept{elicitation}
