% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/07_jacobian.R
\name{verify_jacobian}
\alias{verify_jacobian}
\title{Verify Jacobian Against Finite Differences}
\usage{
verify_jacobian(
  J,
  a,
  b,
  eps = 1e-06,
  M = .QUAD_NODES_VERIFICATION,
  verbose = TRUE
)
}
\arguments{
\item{J}{Integer; sample size.}

\item{a}{Numeric; shape parameter.}

\item{b}{Numeric; rate parameter.}

\item{eps}{Numeric; step size for finite differences (default: 1e-6).}

\item{M}{Integer; number of quadrature nodes (default: 200 for verification).}

\item{verbose}{Logical; if TRUE, print detailed comparison.}
}
\value{
A named list with components:
\describe{
\item{\code{analytic}}{The analytically computed Jacobian}
\item{\code{numeric}}{The numerically computed Jacobian (finite differences)}
\item{\code{abs_error}}{Matrix of absolute errors}
\item{\code{rel_error}}{Matrix of relative errors}
\item{\code{max_rel_error}}{Maximum relative error across all entries}
\item{\code{pass}}{Logical; TRUE if max relative error < 0.01}
}
}
\description{
Compares the analytically computed Jacobian (via score identities) against
numerical finite differences to validate the implementation.
}
\details{
Uses central finite differences:
\deqn{\frac{\partial f}{\partial a} \approx \frac{f(a+\epsilon) - f(a-\epsilon)}{2\epsilon}}

\strong{Important:} This is a SECONDARY verification method because both the
analytical Jacobian and the finite differences use the same quadrature layer.
For independent verification, compare against adaptive integration (scipy.integrate.quad
in Python).
}
\examples{
# Verify Jacobian for a specific case
result <- verify_jacobian(J = 50, a = 2.0, b = 1.0, verbose = TRUE)

}
\keyword{internal}
