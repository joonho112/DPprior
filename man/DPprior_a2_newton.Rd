% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/11_a2_newton.R
\name{DPprior_a2_newton}
\alias{DPprior_a2_newton}
\title{A2-MN Exact-Moment Newton Solver}
\usage{
DPprior_a2_newton(
  J,
  mu_K,
  var_K,
  a0 = NULL,
  b0 = NULL,
  tol_F = .TOL_NEWTON,
  tol_step = 1e-10,
  max_iter = 20L,
  damping = TRUE,
  use_fallback = TRUE,
  M = .QUAD_NODES_DEFAULT,
  verbose = FALSE
)
}
\arguments{
\item{J}{Integer; sample size (number of observations/sites). Must be >= 2.}

\item{mu_K}{Numeric; target prior mean \eqn{E[K_J]}. Must satisfy \eqn{1 < \mu_K < J}.}

\item{var_K}{Numeric; target prior variance \eqn{\mathrm{Var}(K_J)}. Must be positive.}

\item{a0}{Numeric or NULL; initial shape parameter. If NULL, computed via
\code{\link{DPprior_a1}}.}

\item{b0}{Numeric or NULL; initial rate parameter. If NULL, computed via
\code{\link{DPprior_a1}}.}

\item{tol_F}{Numeric; stopping tolerance for the residual norm
||F|| = sqrt((M1 - mu_K)^2 + (V - var_K)^2). Default: 1e-8.}

\item{tol_step}{Numeric; stopping tolerance for Newton step size.
Default: 1e-10.}

\item{max_iter}{Integer; maximum Newton iterations. Default: 20.}

\item{damping}{Logical; if TRUE, use backtracking line search for
damped Newton updates. Default: TRUE.}

\item{use_fallback}{Logical; if TRUE, use Nelder-Mead fallback when Newton
fails to converge. Default: TRUE.}

\item{M}{Integer; number of quadrature nodes for moment computation.
Default: 80.}

\item{verbose}{Logical; if TRUE, print iteration progress. Default: FALSE.}
}
\value{
A \code{DPprior_fit} object (S3 class) with components:
\describe{
\item{\code{a}}{Numeric; optimal shape parameter}
\item{\code{b}}{Numeric; optimal rate parameter}
\item{\code{J}}{Integer; sample size}
\item{\code{target}}{List with \code{mu_K}, \code{var_K}, and \code{type = "moments"}}
\item{\code{method}}{Character; "A2-MN" or "A2-MN+NM" if fallback was used}
\item{\code{status}}{Character; convergence status ("success", "stagnated", "max_iter")}
\item{\code{converged}}{Logical; whether algorithm converged to target tolerance}
\item{\code{iterations}}{Integer; number of iterations}
\item{\code{termination}}{Character; reason for termination ("residual", "step", "max_iter", "nelder_mead")}
\item{\code{fit}}{List with achieved \code{mu_K}, \code{var_K}, and \code{residual}}
\item{\code{diagnostics}}{List with diagnostic information}
\item{\code{trace}}{Data frame with iteration history}
}
}
\description{
Finds Gamma(a, b) hyperprior parameters that exactly match target moments
for the number of clusters K_J under a Dirichlet process prior.
}
\details{
This implements TSMM Stage 2 (A2-MN) from Lee (2026).
The A2-MN algorithm uses Newton's method in log-scale to ensure positivity
of the Gamma parameters. The Jacobian is computed exactly using score
function identities (Lee, 2026, Section 3.2, Corollary 1), avoiding finite difference
approximations.

\strong{Algorithm Steps:}
\enumerate{
\item Initialize: \eqn{(a_0, b_0)} from A1 closed-form or user-provided
\item Log-parameterize: \eqn{\eta = (\log a, \log b)}
\item For each iteration:
\itemize{
\item Compute moments \eqn{(M_1, V)} and Jacobian \eqn{J_F}
\item Compute residual \eqn{F = (M_1 - \mu_K, V - \sigma^2_K)}
\item Transform Jacobian to log-scale: \eqn{J_{\log} = J_F \cdot \text{diag}(a, b)}
\item Newton step: \eqn{\Delta = -J_{\log}^{-1} F}
\item Backtracking line search (if damping enabled)
\item Update: \eqn{\eta \leftarrow \eta + \lambda \Delta}
}
\item Return \eqn{(a, b) = \exp(\eta)}
}

\strong{Convergence Behavior:}
\itemize{
\item For typical targets, converges in 3-8 iterations
\item For targets requiring very small \eqn{a} (quasi-improper priors),
convergence may be slower; the Nelder-Mead fallback handles these cases
\item Machine-precision accuracy (residual < 1e-10) is typically achieved
}

\strong{Termination Conditions:}
\itemize{
\item \code{residual}: ||F|| < tol_F (success)
\item \code{step}: ||delta|| < tol_step (stagnation - may not have converged)
\item \code{max_iter}: maximum iterations reached
\item \code{nelder_mead}: Nelder-Mead fallback succeeded
}

\strong{Error Handling:}
\itemize{
\item If Jacobian becomes singular, falls back to gradient descent
\item If Newton fails after \code{max_iter}, uses Nelder-Mead if enabled
\item Warns for quasi-improper priors (\eqn{a < 0.1})
}
}
\examples{
# Basic usage
fit <- DPprior_a2_newton(J = 50, mu_K = 5, var_K = 8)
print(fit)

# Verify exact moment matching
achieved <- exact_K_moments(50, fit$a, fit$b)
cat(sprintf("Target E[K]=5, Achieved E[K]=\%.10f\n", achieved$mean))
cat(sprintf("Target Var=8, Achieved Var=\%.10f\n", achieved$var))

# Compare A1 vs A2 accuracy
a1 <- DPprior_a1(J = 50, mu_K = 5, var_K = 8)
a1_mom <- exact_K_moments(50, a1$a, a1$b)
a2_mom <- exact_K_moments(50, fit$a, fit$b)
cat(sprintf("A1 mean error: \%.6f\n", abs(a1_mom$mean - 5)))
cat(sprintf("A2 mean error: \%.2e\n", abs(a2_mom$mean - 5)))

# View iteration trace (includes step size and Jacobian determinant)
head(fit$trace)

}
\references{
Lee, J. (2026). Design-Conditional Prior Elicitation for Dirichlet Process Mixtures.
\emph{arXiv preprint} arXiv:2602.06301.
}
\seealso{
\code{\link{DPprior_a1}} for closed-form initialization,
\code{\link{moments_with_jacobian}} for Jacobian computation,
\code{\link{exact_K_moments}} for moment verification

Other elicitation: 
\code{\link{DPprior_a1}()},
\code{\link{DPprior_a2_kl}()},
\code{\link{DPprior_dual}()},
\code{\link{DPprior_fit}()}
}
\concept{elicitation}
